package ch_memo;

public class ch05_memo {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("5챕터 메모장입니다.");
	}
}
/*
 * 상속 - 기존에 만들어진 클래스를 재사용하게 만듬
 * 자바에서 상속 - 부모 클래스를 extends 한다는 뜻
 * extends 라는 키워드를 통해 부모 클래스를 상속 받음, 부모클래스와 자식클래스는 하나가 된다.
 * 한마디로 상속을 받으면 메서드 안에서도 상속 받은 클래스를 사용(변수 등) 가능 하다.
 * 
 * 메서드 오버라이딩(OverRiding) - super 생성자
 * 오버라이딩 - 부모클래스로부터 상속받은 메서드의 내용을 변경하는 것
 * super는 부모클래스로부터 상속 받은 멤버를 참조하는데 사용하는 참조 변수
 * super생성자는 부모클래스의 생성자 호출 시 사용
 * (example ORT01)
 * 
 * 메서드 오버라이딩 - 재정의
 * 부모클래스의 메서드가 필요하지 않는 경우 자식클래스가 재정의하는 것
 * (example ORT02)
 * 
 * 생성자(Constructor)
 * 역할 - 메모리 내에 객체를 생성할 때 해당 생성자를 통하여 기본적인 객체의 구조를 인식하게
 *       하고 생성되는 멤버변수들을 초기화
 * 어떻게 기본적인 세팅을 할 것인가는 생성자의 오버로딩을 통해 지정
 * 생성자명 == 클래스명
 * (example ConstructorTest01) 
 * -> 객체를 생성할때 괄호만 넣었던 이유는 클래스 안에 생략이 되어있기 때문
 * -> 인자가 있는 생성자를 생성하게 되면 ()만 있는 객체 생성은 불가능
 * ---> 이유는 생략되어 있던 빈 괄호만 있는 생성자는 사라지기 때문
 * ---> 그래서 생성자를 호출 할 때는 동일하게 괄호에 인자를 넣어야 함
 * ---> this는 클래스의 변수를 뜻하고 그냥 변수는 괄호안의 인자를 의미
 * 
 * 
 * 생성자의 오버로딩
 * 오버로딩(Overloading) - 기존에 없는 새로운 메서드를 정의하는 것
 * ---> 상속받은 메서드의 내용을 변경하는 오버라이딩과는 분명 차이가 있음
 * (example ConstructorTest02)
 * -> 첫번째 객체는 인자가 하나이지만 타입이 String이므로 해당 타입을 찾아감
 * -> 두번째 객체는 인자가 하나이지만 타입이 int 이기에 해당 타입을 찾아감
 * -> 세번째 객체는 인자가 두개라 해당 타입을 찾아감
 * 
 * 
 * 패키지(package)와 import
 * 내용이 서로 달라도 파일명이 동일하다면 한 공간에 공존할 수 없음
 * -> 그래서 고안된 것이 폴더(디렉토리) 이다.
 * 패키지 - 폴더의 성격과 유사 / 같은 이름의 클래스여도 패키지가 다르기 때문에 구분할 수 있다.
 * import - 다른 패키지에 있는 특정 라이브러리를 나의 클래스에서 사용하기 위해 명시해주는 것
 * 
 * 
 * 패키지 선언 - package 이름; / 숫자나 고유명령어 사용 불가능 
 * --> 패키지는 쉽게 말게 폴더라고 생각하면 됨
 * import 사용 - import 패키지명.클래스명
 * --> 사용할때는 패키지명 생략하고 클래스명만 입력하요 소스코드 입력
 * (example ImportTest01)
 * 
 * 
 * 접근 제어자(access modifier)
 * -> 외부에서 접근하지 못하도록 제어하는 역할
 * -> 클래서, 메서드, 멤버변수, 생성자에 사용할 수 있음
 * public 클래스명 - 다른 패키지에서도 사용 가능
 * private 클래스명 - 자신의 클래스에서만 사용 가능
 * (example AccessControlTest01)
 * (example AccessControlTest02)
 * 
 * protected 클래스명 - 자식클래스에서만 호출 가능
 * (example AccessControlTest03)
 * 
 * 
 * 
 * 
 */